# 一、数据结构

## 1. 树

![image-20231027102530953](images\tree.png)

- **子树：**树是一个有限集合，子树则是该集合的子集。就像套娃一样，一棵树下面还包含着其子树。比如，树T1 的子树为 树T2、T3、T4，树T2的子树为 T5、T6 。
- **结点(Node)：**一个结点包括一个数据元素和若干指向其子树分支。比如，在树T1 中，结点A 包括一个数据元素A 和 三个指向其子树的分支。上图中共有 17 个结点 。
- **根结点(Root)：**一颗树只有一个树根，这是常识。在数据结构中,“树根”即根节点。比如，结点A 是树 T1 的根结点; 结点C 是树T1 的子结点，是树 T3 的根结点。
- **度(Degree)：**一个结点拥有的子树数。比如，结点A 的度为 3，结点G 的度为 3，结点H 的度为 1。
- **叶子(Leaf)/ 终端结点：**度为 0 的结点被称为叶子结点，很形象吧。比如，对于树 T1来说，结点F、I、K、L、M、N、O、P、Q 均为叶子节点。
- **分支结点 / 非终端结点：**和叶子结点相对，即度不为 0 的结点。
- **双亲节点或父节点：**若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点。
- **孩子节点或子节点：**一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点。
- **兄弟节点：**具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点。
- **堂兄弟节点：**双亲在同一层的节点互为堂兄弟节点；如上图：E、G、H互为堂兄弟节点。
- **节点的祖先：**从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先。
- **子孙：**以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙。
- **层次(Level)：**从根结点开始，根为第一层，根的孩子为第二层，依次往下。比如，结点K 在树 T1 中的层次为 4。
- **深度(Depth)/ 高度：**指树的最大层次。比如，树 T1 的高度为 4 。

## 2. 二叉树

![image-20231027103607175](images\binaryTree.png)

- 二叉树就是度不超过2的树，其每个结点最多有两个子结点
- 二叉树的结点分为左结点和右结点。

- 二叉树中，第 i 层最多有$2^{(i-1)}$个结点。
  
- 如果二叉树的深度为 K，那么此二叉树最多有$2^K -1$个结点

- 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。

- 具有n个节点的满二叉树深为$log_2(n+1)$。

  

### 2.1 满二叉树

![image-20231027110239225](images\fullBinary Tree.png)

- 如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。

### 2.2 完全二叉树

![image-20231027110611110](images\completeBinaryTree.png)

- 如果二叉树中除去最后一层节点为满二叉树，且**最后一层的结点依次从左到右分布**，则此二叉树被称为完全二叉树。

### 2.3 二叉搜索树（BST）

![image-20231027110848317](images\binarySearchTree.png)

- 又称: 二叉排序树、二叉查找树
- 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
- 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
- 任意节点的左、右子树也分别为二叉搜索树;

### 2.4 平衡二叉树（AVL）

- **平衡二叉树是一种二叉排序树**，其中每个结点的左子树和右子树的高度差至多等于1。它是二叉排序树的一个进化体
- **平衡因子**：平衡二叉树是在二叉查找树的基础上进行构建，为了维持平衡二叉树的平衡，那么就需要一种机制来判断平衡二叉树是否是平衡的。这种机制就叫做平衡因子。平衡二叉树上某个结点的**左子树深度减去右子树深度的值**，就称**为此结点的平衡因子**。
- 平衡二叉树是一种二叉查找树
- 每个结点的左子树的高度减去右子树的高度的绝对值不超过1
- 空树和左右子树都是平衡二叉树
- 相比红黑树，平衡二叉树比较适用于没有删除的情况

#### 2.4.1 左旋

![image-20231027114914433](images\leftRotate.png)

- 指将根节点的右侧往左拉，原先的右子节点变成新的父节点，并把多余的左子节点出让，给已经降级的根节点当右子节点

#### 2.4.2 右旋

![image-20231027115153298](images\rightRotate.png)

- 指将根节点的左侧往右拉，原先的左子节点变成新的父节点，并把多余的右子节点出让，给已经降级的根节点当左子节点

#### 2.4.3 LL RR LR RL型

![image-20231027115352705](images\rotate.png)

![image-20231027115644304](images\rotateResult.png)

- 左旋和右旋都是以旋转节点为准
- 把key的值为中等的变为树的根，最小的放在左孩子，最大的放右孩子
- 树的旋转，如LL型被称为右旋，RR型称为左旋，LR型是先左旋，再右旋，RL型先右旋再左旋。

### 2.5 红黑树

![image-20231027130912377](images\redBlackTree.png)

- **红黑树**，是一种**二叉搜索树**，但在**每个结点上增加一个存储位表示结点的颜色**，**可以是Red或Black**。 通过**任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍**，因而是**接近平衡**的。
- 结点不是红色就是黑色。
- 根节点是黑色的。
- 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）。
- 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。
- 每个叶子结点都是黑色的(叶结点即指树尾端NIL指针或NULL结点)。
- 红黑树和AVL树都是高效的平衡二叉树，增删改查的时间复杂度都是$O(log_2n)$，红黑树不追求绝对平衡，只需保证最长路径不超过最短路径的2倍，相对而言，降低了插入和旋转的次数，所以在经常进行增删的结构中**性能比AVL树更优，而且红黑树实现比较简单，所以实际运用中红黑树更多**。

## 3. B树（B-树）

![image-20231027131330872](images\3BTree.png)

- B树和AVL树(平衡二叉树) 的差别就是 B树 属于多叉树，又名平衡多路查找树，即一个结点的查找路径不止左、右两个，而是有多个。数据库索引技术里大量使用者B树和B+树的数据结构。一个结点存储多个值(索引)。
- B树的阶数：M阶表示 一个B树的结最多有多少个查找路径(即这个结点有多少个子节点)。M=M路，M=2是二叉树，M=3则是三叉树。
- 每个结点的值(索引) 都是按递增次序排列存放的，并遵循左小右大原则。
- 根结点的 子节点 个数为 [2，M]
- 除 根结点 以外 的 非叶子结点 的子节点个数 为[ Math.ceil(M/2)，M]。 Math.ceil() 为向上取整。
- 每个 非叶子结点 的值(索引) 个数 = 子节点个数 -1 。最小为 Math.ceil(M/2)-1   最大为 M-1 个。
-  B树的所有叶子结点都位于同一层。
- 在数据库查询中，以树存储数据。树有多少层，就意味着要读多少次磁盘IO。所以树的高度越矮，就意味着查询数据时，需要读IO的次数就越少。（众所周知，读IO是一件费事的操作）当数据量大的时候，用AVL树存的话，就算AVL是平衡树，但是也扛不住数据量大，数据量大，AVL树的树高肯定很高，那么读取数据的IO次数也会多。那么有没有办法能压缩AVL树的树高呢？这时候B树就出来了。B树的一个结点可以装多个值，读取时，是把整个结点读到内存，然后在内存中，对结点的值进行处理，在内存中处理速度肯定比磁盘快。所以只要树的高度低，IO少，就能够提升查询效率，这是B树的好处之一。
- B树的每一个结点都包含key(索引值) 和 value(对应数据)，因此方位离根结点近的元素会更快速。（相对于B+树）

## 4. B+树

![image-20231027131549584](images\B+Tree.png)

- B+树内部有两种结点，一种是索引结点，一种是叶子结点。
- B+树的索引结点并不会保存记录，只用于索引，所有的数据都保存在B+树的叶子结点中。而B树则是所有结点都会保存数据
- B+树的叶子结点都会被连成一条链表。叶子本身按索引值的大小从小到大进行排序。即这条链表是 从小到大的。多了条链表方便范围查找数据
- B树的所有索引值是不会重复的，而B+树 非叶子结点的索引值 最终一定会全部出现在 叶子结点中。

### B树好处：

- B树的每一个结点都包含key(索引值) 和 value(对应数据)，因此方位离根结点近的元素会更快速。（相对于B+树）


### B树的不足：

- 不利于范围查找(区间查找)，如果要找 0~100的索引值，那么B树需要多次从根结点开始逐个查找。


- 而B+树由于叶子结点都有链表，且链表是以从小到大的顺序排好序的，因此可以直接通过遍历链表实现范围查找

## 5.HashMap

### 5.1 HashMap的hash原理

- HashMap 是一种常用的哈希表实现，它将键（key）映射到值（value）上。它使用哈希函数将键映射到哈希表中的索引，以便快速查找键值对。HashMap 的实现基于数组和链表或红黑树，它通过散列函数来确定每个键值对在数组中的位置

- ```java
  //重新计算哈希值
  static final int hash(Object key) {
      int h;
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);//key如果是null 新hashcode是0 否则 计算新的hashcode
  }
  ```

- 将h无符号右移16为相当于将高区16位移动到了低区的16位，再与原hashcode做异或运算，可以将高低位二进制特征混合起来

- 在算出hash值之后,计算这个key落在哪一个桶上面,方法有2中,一种是&,一种是%,这两种方法都可行,但是效率不一样,新哈希值在后面将会参与hashmap中数组槽位的计算，计算公式：(n - 1) & hash，

- 异或运算能更好的保留各部分的特征，如果采用&运算计算出来的值会向0靠拢，采用|运算计算出来的值会向1靠拢

- 为了让哈希后的结果更加均匀，槽位数必须使用$2^n$

# 二、算法

